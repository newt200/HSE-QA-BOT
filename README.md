# HSE-QA-BOT

Это небольшой проект, где мы собрали базу вопросов-ответов и сделали Telegram-бота, который отвечает пользователям, находя наиболее подходящий ответ в нашей базе.

Идея простая: пользователь задаёт вопрос обычным текстом, а бот пытается сопоставить его с одним из FAQ-вопросов в базе и вернуть связанный с ним готовый ответ.

---

## Как устроено

### Данные
Мы используем SQLite-базу `qa.db`, в которой лежат:

- **`qa`** — основная таблица с записями:
  - `id`
  - `page` (раздел/категория, если есть)
  - `question` (FAQ-вопрос)
  - `answer_text` (готовый ответ)
  - `source_url` (ссылка на источник, если есть)

- **`qa_vec`** — таблица с предвычисленными эмбеддингами (векторами) вопросов и/или ответов, чтобы быстро искать похожее по смыслу:
  - `qa_id`
  - `model_name`
  - `dim`
  - `q_vec` (эмбеддинг вопроса)
  - `a_vec` (эмбеддинг ответа, если мы его тоже считали)

> Эмбеддинги уже нормализованы, поэтому косинусная близость считается как скалярное произведение.

---

## Поиск ответа (retrieval)

В текущей версии мы используем **dense retrieval**:

1. Берём эмбеддинг пользовательского запроса с помощью `SentenceTransformer`.
2. Ищем ближайшие кандидаты по FAISS (быстрое приближённое/точное векторное сходство).
3. Смотрим на лучший скор `s1` (похожесть топ-1).
4. Если `s1` ниже порога `sem_thr`, то **отклоняем запрос** (reject) и просим переформулировать.
5. Если `s1` выше порога — возвращаем найденный ответ.

То есть бот не пытается “ответить любой ценой”: если в базе нет близкого вопроса, мы честно говорим, что подходящего ответа нет.

---

## Файлы проекта

- `bot.py` — Telegram-бот: команды, кнопки, отправка ответов пользователю.
- `find_candidates.py` — поиск кандидатов: загрузка эмбеддингов из БД, построение FAISS-индекса, поиск top-k и reject по порогу.
- `qa.db` — SQLite база с вопросами/ответами и эмбеддингами.

---

## Установка

### 1) Python и виртуальное окружение
```bash
python -m venv venv
source venv/bin/activate
